# SGP30 library for RP2040

This is a library I created for my [personal project](https://github.com/skylordants/Pico_receiver). I'm sharing it, in case it is helpful to somebody and to make my code public, but I don't intend on regularily maintaining it, because it works for me, unless something big happens.

## Usage
The simplest way to use the library is to include it in a platformio project using [wizio-pico baremetal](https://github.com/Wiz-IO/wizio-pico) platform, but other projects using the RP2040 SDK should work as well. It depends on my [I2C](https://github.com/skylordants/rp2040_i2c) and [AT93C46](https://github.com/skylordants/rp2040_at93c46) libraries, but can be made to work without the first one quite easily, if necessary, and the second dependency with all the code referencing it can be removed without breaking the sensor functionality. I didn't add some preprocessor definition to check, if it should be included, because it would make the code more complicated and I couldn't be bothered. If anyone wants to use this library and needs help with that, I would be more than glad to help and even add that functionality, if people are interested in it (assuming, that people want to use it, not to talk about finding it, which is improbable). But the code should work well, even if you don't have that specific eeprom and don't remove the stuff related to it.

An SGP30 object can be created by calling it's constructor and giving it pointers to the AR93C46 eeprom object and the I2C object from my libraries, and a bool specifying, whether the currently saved baseline in the eeprom should be used if it is valid, or if you want to calibrate the sensor again. The pointer to the eeprom could be *NULL*, if it isn't present, and everything should work, although the bool won't do anything then and for the first 12 hours the measurements aren't that good apparently. The bool is for manual resetting of the baseline by for example a button press on startup, if it is too old or it has changed places.

After that, the only thing to do is to call the *measure_air_quality* method approximately once every second or in other words with a frequency of 1 Hz. The sensor should work best with that frequency. The function can be called in the main loop by using a delay or checking the last time it was called. Or it can be put in a timer callback or separate thread, if using RTOS. The last measurement values can be found from the variables *co2eq* and *tvoc* in units of ppm and ppb respectively. The values are updated every time the *measure_air_quality* returns *true*.

If possible, the current absolute humidity should also be given to the sensor by the method *set_humidity* in intervals of for example 5 seconds.

## Sources
Most of the stuff is based on the [datasheet](https://www.mouser.com/pdfdocs/Sensirion_Gas_Sensors_SGP30_Datasheet_EN-1148053.pdf). For implementing the CRC, an [article](http://www.sunshine2k.de/articles/coding/crc/understanding_crc.html) by Sunshine was extremely helpful. Adafruit's [SGP30](https://github.com/adafruit/Adafruit_SGP30) library, especially it's [documentation](https://cdn-learn.adafruit.com/downloads/pdf/adafruit-sgp30-gas-tvoc-eco2-mox-sensor.pdf), and the [SGP30 Driver Integration Guide](https://files.seeedstudio.com/wiki/Grove-VOC_and_eCO2_Gas_Sensor-SGP30/res/Sensirion_Gas_Sensors_SGP30_Driver-Integration-Guide_HW_I2C.pdf) ([source code](https://github.com/Sensirion/embedded-sgp)) were very helpful in understanding how the baseline works, but I didn't use any code from them, so I hope I'm not commiting any license infringment.
